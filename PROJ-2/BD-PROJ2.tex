\documentclass[11pt,a4paper]{article}
 
\usepackage{amsmath}
\usepackage{authblk}
\usepackage[portuguese]{babel}
\usepackage{enumitem}
\usepackage{eurosym}\def\texteuro{\euro}
\usepackage{fancyhdr}
\usepackage[T1]{fontenc}
\usepackage[hmargin=2cm,vmargin=3.5cm,bmargin=3cm]{geometry}
\usepackage{listings} % for code snippets
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{lastpage}
\usepackage{listings}

% listing environment for code
\lstnewenvironment{code}[1][]%
  {\noindent\minipage{\linewidth}\medskip 
   \lstset{basicstyle=\ttfamily\footnotesize,frame=single,#1}}
  {\endminipage}

\newcommand{\select}{\mbox{\Large$\sigma$}}
%\pagenumbering{arabic}
\title{\textbf{Projecto de Bases de Dados, Parte 2}}

\author{Bruno Cardoso (72619), Lídia Freitas (78559) e Rodrigo Bernardo (78942)} 
\affil{Instituto Superior Técnico}

\pagestyle{fancy}
\cfoot{Página \thepage\ de \pageref{LastPage}}

\begin{document}
\date {\today}

\maketitle
\thispagestyle{empty} % remove numeracao na primeira pagina
\centerline{\includegraphics[width=0.4\textwidth]{ist-simbolo.jpg}}

\begin{description}[noitemsep]
	\item \centering{Grupo 17}
	\item Turno: Quinta-Feira, 08h00, LAB 14
\end{description}

\newpage

\tableofcontents
\newpage

\section{Introdução}
\newpage

\section{Consultas SQL}
% http://sqlformat.org/
\begin{enumerate}[label=(\alph*)]
	\item Quais são os utilizadores que falharam o login mais vezes do que tiveram sucesso?
	
		\begin{code}[language=SQL]
SELECT userid
FROM login AS l
WHERE sucesso = 0
GROUP BY userid
HAVING count(*) > ALL
    (SELECT count(*)
     FROM login AS l1
     WHERE sucesso = 1
         AND l1.userid =l.userid);
		\end{code}

	\item Quais são os registos que aparecem em todas as paginas de um utilizador?
	
	A query utiliza \textit{ID\_USER} que deve ser substituido pelo id do utilizador desejado (userid):
		\lstset{emph={ID_USER}, emphstyle=\itshape} % da enfase a palavra ID_USER
		\begin{code}[language=SQL]
SELECT r.regcounter
FROM registo AS r
WHERE r.ativo
    AND r.userid = ID_USER
    AND NOT EXISTS
        (SELECT p.pagecounter
         FROM pagina AS p
         WHERE p.userid = ID_USER
             AND r.regcounter NOT IN
                 (SELECT rp.regid
                  FROM reg_pag AS rp
                  WHERE rp.regid = r.regcounter
                      AND rp.pageid = p.pagecounter
                      AND rp.userid = ID_USER
                      AND rp.ativa
                      AND p.ativa
                      AND EXISTS
                          (SELECT tp.typecnt
                           FROM tipo_registo AS tp
                           WHERE tp.typecnt = rp.typeid
                               AND tp.userid = ID_USER
                               AND tp.ativo)))
        		\end{code}
	\item Quais os utilizadores que têm o maior número médio de registos por página?
	
		\begin{code}[language=SQL]
SELECT userid
FROM reg_pag
WHERE ativa=1
GROUP BY userid
HAVING count(*) / count(DISTINCT pageid) >= all
    (SELECT count(*) / count(DISTINCT pageid)
     FROM reg_pag
     WHERE ativa=1
     GROUP BY userid);
		\end{code}
	
	\item Quais os utilizadores que, em todas as suas páginas, têm registos de todos os tipos de registos que criaram?
\end{enumerate}

\subsection{Notas sobre as Consultas SQL}
\subsubsection{Consulta b -  Quais são os registos que aparecem em todas as páginas de um utilizador?}
Para esta consulta assume-se que se um utilizador não tem páginas então é impossível um registo desse mesmo utilizador aparecer em alguma(s) página(s) (devido à inexistência destas).

Entendeu-se também com esta questão que eram pedidos os registos que aparecem em todas as páginas de um dado utilizador, caso contrário diria "para cada o utilizador". No entanto, como o número de casos em que o facto é verídico é baixo decidimos verificar então quais os registos por todos os utilizadores que verificavam a consulta, e por isso deixamos em baixo a consulta que nos permitiu ver essa informação:

\begin{code}[language=SQL]
SELECT r_0.userid,
       r_0.regcounter
FROM registo AS r_0
WHERE regcounter IN
        (SELECT r.regcounter
         FROM registo AS r
         WHERE r.ativo
             AND r.userid = r_0.userid
             AND NOT EXISTS
                 ( SELECT p.pagecounter
                  FROM pagina AS p
                  WHERE p.userid = r_0.userid
                      AND r.regcounter NOT IN
                          ( SELECT rp.regid
                           FROM reg_pag AS rp
                           WHERE rp.regid = r.regcounter
                               AND rp.pageid = p.pagecounter
                               AND rp.userid = r_0.userid
                               AND rp.ativa
                               AND p.ativa
                               AND EXISTS
                                   ( SELECT tp.typecnt
                                    FROM tipo_registo AS tp
                                    WHERE tp.typecnt = rp.typeid
                                        AND tp.userid = r_0.userid
                                        AND tp.ativo))))
GROUP BY r_0.userid,
         r_0.regcounter
\end{code}

\newpage

\section{Restrições de Integridade}
\newpage
\section{Formas Normais}

\begin{itemize}
	\item[(a)]
	A relação utilizador, tem apenas as dependências funcionais (DFs) da forma \textit{X $\to$ A},
	com \textit{A} pertencente aos atributos desta relação, \textit{X  $\subseteq$ \{userid, email\}}
	e \textit{X $\neq \emptyset$}. Como em todas estas DFs se tem que o determinante é chave,
	a relação utilizador encontra-se na \textit{Boyce-Codd Normal Form} (BCNF).

	\item[(b)]
	Para além das DFs anteriores, a relação tem agora uma nova DF na qual o determinante
	não é chave, mas o dependente é. Assim, a relação utilizador encontra-se na terceira forma
	normal.

	A decomposição proposta é a seguinte:
	\begin{flalign*}
		&R_1(\underline{nome}, email, \underline{password}, \underline{questao1}, \underline{resposta1}, \underline{questao2}, \underline{resposta2}) \\
		&R_2(\underline{userid}, nome, password, questao1, resposta1, questao2, resposta2, pais, categoria).\nonumber
	\end{flalign*}
	Ambas as relações estão na BCNF, pois todas as suas DFs têm chaves como determinantes.
\end{itemize}

\newpage
\section{Índices}
\newpage
\section{Transacções}

\newpage

\section{Data Warehouse}
\newpage

\section{Conclusão}
\newpage

\end{document}
