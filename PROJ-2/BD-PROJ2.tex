\documentclass[11pt,a4paper]{article}
 
\usepackage{amsmath}
\usepackage{authblk}
\usepackage[portuguese]{babel}
\usepackage{enumitem}
\usepackage{eurosym}\def\texteuro{\euro}
\usepackage{fancyhdr}
\usepackage[T1]{fontenc}
\usepackage[hmargin=2cm,vmargin=3.5cm,bmargin=3cm]{geometry}
\usepackage{listings} % for code snippets
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{lastpage}
\usepackage{listings}

\newcommand{\select}{\mbox{\Large$\sigma$}}
%\pagenumbering{arabic}
\title{\textbf{Projecto de Bases de Dados, Parte 2}}

\author{Bruno Cardoso (72619), Lídia Freitas (78559) e Rodrigo Bernardo (78942)} 
\affil{Instituto Superior Técnico}

\pagestyle{fancy}
\cfoot{Página \thepage\ de \pageref{LastPage}}

\begin{document}
\date {\today}

\maketitle
\thispagestyle{empty} % remove numeracao na primeira pagina
\centerline{\includegraphics[width=0.4\textwidth]{ist-simbolo.jpg}}

\begin{description}[noitemsep]
	\item \centering{Grupo 17}
	\item Turno: Quinta-Feira, 08h00, LAB 14
\end{description}

\newpage

\tableofcontents
\newpage

\section{Introdução}
\newpage

\section{Consultas SQL}
% http://sqlformat.org/
\begin{enumerate}[label=(\alph*)]
	\item Quais são os utilizadores que falharam o login mais vezes do que tiveram sucesso?
		\begin{lstlisting}[language=SQL]
SELECT userid
FROM login AS l
WHERE sucesso = 0
GROUP BY userid
HAVING count(*) > ALL
    (SELECT count(*)
     FROM login AS l1
     WHERE sucesso = 1
         AND l1.userid =l.userid);
		\end{lstlisting}

	\item Quais são os registos que aparecem em todas as paginas de um utilizador?
	
	A query utiliza \textit{ID\_USER} que deve ser substituido pelo id do utilizador desejado (userid):
		\lstset{emph={ID_USER}, emphstyle=\itshape} % da enfase a palavra ID_USER
		\begin{lstlisting}[language=SQL]
SELECT r.regcounter
FROM registo AS r
WHERE r.ativo = 1
    AND r.userid = ID_USER
    AND NOT EXISTS
        ( SELECT p.pagecounter
         FROM pagina AS p
         WHERE p.userid = ID_USER
             AND r.regcounter NOT IN
                 ( SELECT rp.regid
                  FROM reg_pag AS rp
                  WHERE rp.regid = r.regcounter
                      AND rp.pageid = p.pagecounter
                      AND rp.userid = ID_USER
                      AND rp.ativa = 1
                      AND p.ativa ))
        		\end{lstlisting}
	\item Quais os utilizadores que têm o maior número médio de registos por página?
		\begin{lstlisting}[language=SQL]
SELECT userid
FROM reg_pag
WHERE ativa=1
GROUP BY userid
HAVING count(*) / count(DISTINCT pageid) >= all
    (SELECT count(*) / count(DISTINCT pageid)
     FROM reg_pag
     WHERE ativa=1
     GROUP BY userid);
		\end{lstlisting}
	
	\item Quais os utilizadores que, em todas as suas páginas, têm registos de todos os tipos de registos que criaram?
\end{enumerate}

\newpage

\section{Restrições de Integridade}
\newpage
\section{Formas Normais}

\begin{itemize}
	\item[(a)]
	A relação utilizador, tem apenas as dependências funcionais (DFs) da forma \textit{X $\to$ A},
	com \textit{A} pertencente aos atributos desta relação, \textit{X  $\subseteq$ \{userid, email\}}
	e \textit{X $\neq \emptyset$}. Como em todas estas DFs se tem que o determinante é chave,
	a relação utilizador encontra-se na \textit{Boyce-Codd Normal Form} (BCNF).

	\item[(b)]
	Para além das DFs anteriores, a relação tem agora uma nova DF na qual o determinante
	não é chave, mas o dependente é. Assim, a relação utilizador encontra-se na terceira forma
	normal.

	A decomposição proposta é a seguinte:
	\begin{flalign*}
		&R_1(\underline{nome}, email, \underline{password}, \underline{questao1}, \underline{resposta1}, \underline{questao2}, \underline{resposta2}) \\
		&R_2(\underline{userid}, nome, password, questao1, resposta1, questao2, resposta2, pais, categoria).\nonumber
	\end{flalign*}
	Ambas as relações estão na BCNF, pois todas as suas DFs têm chaves como determinantes.
\end{itemize}

\newpage
\section{Índices}
\newpage
\section{Transacções}

\newpage

\section{Data Warehouse}
\newpage

\section{Conclusão}
\newpage

\end{document}
